author   = Jo Pol
version  = 0.1

name     = Blueprint based reports and exports
info     =  <h1><center>Blueprint based reports and exports</center></h1>
 <p>
  The default blueprints count names, gives a time line for an individual or reveals the composition of a patchwork family.
 </p>
 <p><b>
  Needs the jar files in
  <a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a>
 </b></p>
 <h2>Step 1: SPARQL query</h2>
 <p>
  The first step of a blueprint is a
  <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a> query.
  A query can compare plain complete Gregorian dates.
  The formats with extension n3 and ttl have a lot in common with SPARQL,
  so examining the converted gedcom can help to write other queries.
  These versions of the converted gedcom should also be easy to compare with the Gedcom mode of GENJ's edit view.
 </p>
 <p>
  You can find multiline versions (easier to read for humans) of the default queries in the 
  <a href="https://genj.svn.sourceforge.net/svnroot/genj/trunk/genj/src/report/rdf/ReportRdf.properties">properties</a>
  files. Locate this file on your system to avoid version conflicts. 
  The default queries are intended as examples showing various tricks of the trade.
  The family-based query shows the configuration of a patchwork family, e.g. a remarried widow and widower.
  The individual-based query produces a time line and the gedcom-based query counts names.
 </p>
 <h2>Step 2: mark up</h2>
 <p>
  The second step of a blueprint is a transformation into HTML (or whatever) with an
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">xsl style sheet</a> or
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>, 
  the links go to examples that generate a plain HTML table layout.
  The options allow to put your copy of the style sheet in the generated XML file.
  An XSL style sheet and the query result should be published in the same domain.
  For xQuery you need to put the name of the generated XML file in the xQuery file.
 </p>
 <h2>Options</h2>
 <h3>URI's for entities</h3>
 <p>
  URI's may look like URL's, but they are universal resource <em>identifiers</em>, 
  they need not but might <em>locate</em> an actual web page.
 </p>
 <h3>Output</h3>
 <p>
  Output can be generated into files, or in the report view. 
  In the latter case you can select entities by double clicking their ID's.
  The query is always echoed to the report view to locate syntax errors.
 </p>
 <h3>Queries</h3>
 <p>
  You can write a query directly in the option field, or specify a file containing the query.
  An empty query field restores the default example as soon as it gets executed. 
  A '%s' in a query is a place holder for the id of the entity from which the report was launched.
 </p>
 <h2>To do</h2>
 <ul>
  <li>For more powerful queries we need rules for ancestors and descendants.</li>
  <li>Propably ID's returned by a SPAQRQL query could be used as an export filter</li>
  <li>See TODO's in the code and properties files</li>
 </ul>
 
# TO DO continued #########################################
#
# rules: http://www.agfa.com/w3c/euler/gedcom-relations.n3 (by Jos De Roo / AGFA)
# more context at http://lists.w3.org/Archives/Public/www-rdf-logic/2001Mar/0018.html
# needs adjustments to our model as we use a simple 1:1 conversion from gedcom in stead of DAML
#
# see http://jena.sourceforge.net/inference/#RULEexamples

###########################################################
#################### option labels ########################
###########################################################

uriFormats = format for entity URIs ({0} is a place holder for id's)

fam = family
indi = individual
obje = object
note = note
sour = source
repo = repository
subm = submitter

displayFormats = which results and how to show them (clear file name to skip, # to show in panel)

styleSheet = file name of XSL style sheet (gets embedded in the XML result)
converted = file name for converted gedcom (extensions: "ttl", "n3", "nt", "rdf")
asXml = file name for query result as XML
asText = file name for query result as plain text
askForOverwrite = ask before overwriting existing files

queries = SPARQL queries (see explanation, clear to restore defualt)

qFam = family is selected entity
qIndi = individual is selected entity
qGedcom = no entity selected

###########################################################
#################### messages #############################
###########################################################

progress.writing = ######## writing {0}
overwrite.question = {0} allready exists. Overwrite it?
extension.error = "{0}" is not a valid extension for the converted gedcom.
 Use for example "#.n3" to show the output in the report view.

#################################################################################
######### sample queries, you may want to translate the bindings (?xxx) #########
#################################################################################

# count first names
query.gedcom = SELECT count(?indi) ?x
 {?indi a t:INDI ; p:NAME [p:first ?name] .
   LET (?x := str(?name))
 }
 GROUP BY ?x
 ORDER BY ?x

# shows the configuration of a patchwork family (remarried widow and widower)
query.fam = SELECT DISTINCT ?name1 ?name2 (str(?firstName) as ?child)
 {?fam1 
   p:id '%s';
   p:HUSB ?husb1.
  ?indi1
   p:FAMS ?fam1, ?fam2;
   p:NAME [p:value ?name1].
  ?indi2
   p:FAMS ?fam2;
   p:NAME [p:value ?name2].
  ?fam2 p:CHIL ?child2.
  ?child2 p:NAME [p:value ?nameChild; p:last ?lastName; p:first ?firstName;].
  FILTER( ?indi1 != ?indi2 && ?indi2 != ?husb1)
 }

query.indi = SELECT DISTINCT 
  (str(?eventDate) as ?date)
  ((?birthDate <= ?eventDate && ?eventDate <= ?deathDate) as ?selectedPersonAlive)
  ?eventType
  ?name
 {?indi 
   p:id '%s';
   p:NAME [p:value ?nameIndi];
   p:BIRT [p:DATE ?birthDate];
   p:DEAT [p:DATE ?deathDate];
   p:FAMC ?famC.
  {?indi                              p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth").}UNION
  {?indi                              p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death").}UNION
  {?indi r:dad ?dad.             ?dad p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth dad").}UNION
  {?indi r:dad ?dad.             ?dad p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death dad").}UNION
  {?indi r:mom ?mom.             ?mom p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth mom").}UNION
  {?indi r:mom ?mom.             ?mom p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death mom").}UNION
  {?indi r:son ?son.             ?son p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth son").}UNION
  {?indi r:son ?son.             ?son p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death son").}UNION
  {?indi r:son ?daughter.   ?daughter p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth daughter").}UNION
  {?indi r:son ?daughter.   ?daughter p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death daughter").}UNION
  {?indi r:spouse ?spouse.    ?spouse p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth spouse").}UNION
  {?indi r:spouse ?spouse.    ?spouse p:NAME [p:value ?name]; p:DEAT [p:DATE ?eventDate]. LET (?eventType := "death spouse").}UNION
  {?indi r:sibling ?sibling. ?sibling p:NAME [p:value ?name]; p:BIRT [p:DATE ?eventDate]. LET (?eventType := "birth sibling").}
 }ORDER BY ?eventDate

#################################################
######### below no further translations   #######
#################################################

queryFunctions = \n
 PREFIX  r: <http://genj.sourceforge.net/rdf/gedcom/rule/> \n
 \n
 PREFIX  fn: <http://www.w3.org/2005/xpath-functions#> \n
 PREFIX afn: <http://jena.hpl.hp.com/ARQ/function#> \n
 PREFIX apf: <http://jena.hpl.hp.com/ARQ/property#> \n
 \n
 
rules = 
 [(?fam p:WIFE ?wife)(?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)]
 [(?fam p:HUSB ?dad )(?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:dad ?dad)(?child r:parent ?dad)]
 [(?fam p:WIFE ?mom )(?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:mom ?mom)(?child r:parent ?mom)]
 [(?fam p:HUSB ?dad )(?fam p:CHIL ?child  )(?child p:SEX ?s)(?s p:value "M")->(?dad r:son      ?child)]
 [(?fam p:HUSB ?dad )(?fam p:CHIL ?child  )(?child p:SEX ?s)(?s p:value "F")->(?dad r:daughter ?child)]
 [(?fam p:WIFE ?mom )(?fam p:CHIL ?child  )(?child p:SEX ?s)(?s p:value "M")->(?mom r:son      ?child)]
 [(?fam p:WIFE ?mom )(?fam p:CHIL ?child  )(?child p:SEX ?s)(?s p:value "F")->(?mom r:daughter ?child)]
 [(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)(?c2 r:sibling ?c1)]
