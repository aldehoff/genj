author   = Jo Pol
version  = 0.1

name     = Blueprint based reports and exports
info     =  <h1><center>Blueprint based reports and exports</center></h1>
 <p><b>
  Needs the jar files in
  <a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a>
 </b></p>
 <h2>step 1: SPARQL query</h2>
 <p>
  The first step of a blueprint is a
  <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a> query.
  A query can calculate with plain complete Gregorian dates.
  The default queries are intended as examples.
  Examining the converted gedcom can help to write other queries.
  because the formats with extension n3 and ttl have a lot in common with SPARQL.
  These formats should also be easy to compare with the Gedcom mode of GENJ's edit view.
 </p>
 <h2>step 2: mark up</h2>
 <p>
  The second step of a blueprint is a transformation into HTML (or whatever) with an
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">xsl style sheet</a> or
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>, 
  the links go to examples that generate a plain HTML table layout.
  The options allow to put your copy of the style sheet in the generated XML file.
  An XSL style sheet and the query result should be published in the same domain.
  For xQuery you need to put the name of the generated XML file in the xQuery file.
 </p>
 <h2>Options</h2>
 <p>
  Output can be generated into files, or in the report view. 
  In the latter case you can select entities by double clicking their ID's.
  The query is always echoed to the report view to locate syntax errors.
 </p>
 <p>
  You can write a query directly in the option field, or specify a file containing the query.
  An empty query field restores the default example.
 </p>
 <h2>To do</h2>
 <ul>
  <li>For more powerful queries we need rules for ancestors and descendants.</li>
  <li>Propably ID's returned by a SPAQRQL query could be used as an export filter</li>
  <li>See TODO's in the code and properties files</li>
 </ul>
 
# TO DO continued #########################################
#
# rules: http://www.agfa.com/w3c/euler/gedcom-relations.n3 (by Jos De Roo / AGFA)
# more context at http://lists.w3.org/Archives/Public/www-rdf-logic/2001Mar/0018.html
# needs adjustments to our model as we use a simple 1:1 conversion from gedcom in stead of DAML
#
# but see http://tech.groups.yahoo.com/group/jena-dev/message/42968
# alternatives
# http://hydrogen.informatik.tu-cottbus.de/wiki/index.php/Jena_Rules_Examples
# http://jena.sourceforge.net/inference/#RULEexamples

###########################################################
#################### option labels ########################
###########################################################

uriFormats = format to assemble URIs ({0} becomes I99, F99 etc)
fam = family
indi = individual
obje = object
note = note
sour = source
repo = repository
subm = submitter

displayFormats = which results and how to show them (# as file name means show in report view, clear file name to skip)

styleSheet = XSL style sheet (gets embedded in the XML result)
converted = file name for converted gedcom (extensions: "ttl", "n3", "nt", "rdf")
asXml = file name for query result as XML
asText = file name for query result as plain text
askForOverwrite = ask before overwriting existing files

queries = SPARQL queries (%s in a query becomes the id of the selected entity)
qFam = family is selected entity
qIndi = individual is selected entity
qGedcom = no entity selected

progress.writing = ######## writing {0}
overwrite.question = {0} allready exists. Overwrite it?
extension.error = "{0}" is not a valid extension for the converted gedcom.
 Use for example "#.n3" to show the output in the report view.

#################################################################################
######### sample queries, you may want to translate the bindings (?xxx) #########
#################################################################################

query.gedcom = SELECT count(?indi) ?x
 {?indi a t:INDI ; p:NAME [p:first ?name] .
   LET (?x := str(?name))
 }
 GROUP BY ?x
 ORDER BY ?x

query.fam = SELECT DISTINCT ?name1 ?name2 (str(?firstName) as ?child)
 {?fam1 
   p:id '%s';
   p:HUSB ?husb1.
  ?indi1
   p:FAMS ?fam1, ?fam2;
   p:NAME [p:value ?name1].
  ?indi2
   p:FAMS ?fam2;
   p:NAME [p:value ?name2].
  ?fam2 p:CHIL ?child2.
  ?child2 p:NAME [p:value ?nameChild; p:last ?lastName; p:first ?firstName;].
  FILTER( ?indi1 != ?indi2 && ?indi2 != ?husb1)
 }

query.indi = SELECT ?indi ?name
 {?indi
  a t:INDI; 
  p:id '%s';
  p:NAME [p:value ?name].
 }

#################################################
######### below no further translations #########
#################################################

queryFunctions = \n
 PREFIX  fn: <http://www.w3.org/2005/xpath-functions#> \n
 PREFIX afn: <http://jena.hpl.hp.com/ARQ/function#> \n
 PREFIX apf: <http://jena.hpl.hp.com/ARQ/property#> \n
