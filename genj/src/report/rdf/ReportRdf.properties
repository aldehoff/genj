author   = Jo Pol
version  = 0.3

name     = Blueprint based reports and exports
info     =  <h1><center>Blueprint based reports and exports</center></h1>
 <h2>Default reports</h2>
 <ul>
  <li>Large age difference between husband and wife.</li>
  <li>Time line with birth death and marriages of close relatives.</li>
  <li>Composition of a patchwork family.</li>
 </ul>
 <p>
  A full fledged report needs two steps, skip the second step if the looks are not important.
 </p>
 <h2>Step 1: Create a SPARQL query (or tweak an existing one)</h2>
 <p>
  The first step of a blueprint is a
  <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a> query.
  A query can compare plain complete Gregorian dates.
  The formats with extension n3 and ttl have a lot in common with SPARQL,
  so examining the converted gedcom can help to write other queries.
  These versions of the converted gedcom should also be easy to compare with the Gedcom mode of GENJ's edit view.
 </p>
 <p>
  You can find multiline versions (easier to read for humans) of the default queries in the 
  <a href="https://genj.svn.sourceforge.net/svnroot/genj/trunk/genj/src/report/rdf/ReportRdf.properties">properties</a>
  file. Locate this file on your system to avoid version conflicts. 
  The default queries are intended as examples showing various tricks of the trade.
  The age difference report is easily turned into a statistical report: 
  drop or invert the filter and select just "avg(?diff)".
 </p>
 <p>
  Rules may provide handy shortcuts for the queries, 
  but they easily require (too) much resources. So only a few rules are active. 
  You can find more rules in the properties file mentioned above.
 </p>
 <h2>Step 2: Tweak the layout</h2>
 <p>
  The second step of a blueprint is a transformation into HTML (or whatever) with an
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">xsl style sheet</a> or
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>, 
  follow the links to download examples that generate a plain HTML table layout.
  The options allow to put your copy of the style sheet in the generated XML file.
  An XSL style sheet and the query result should be published in the same domain.
  For xQuery you need to put the name of the generated XML file in the xQuery file.
 </p>
 <h2>Options</h2>
 <h3>URI's for entities</h3>
 <p>
  To enable the SPARQL queries, the gedcom needs a conversion.
  The new format requires to turn the ID's into URI's.
  URI's may look like URL's, but they are universal resource <em>identifiers</em>, 
  they need not but might <em>locate</em> an actual web page.
  If the formats are unique per gedcom, you could paste the converted gedcoms together 
  to query them with another SPARQL tool.
 </p>
 <h3>Output</h3>
 <p>
  Output can be generated into files, or in the report view. 
  In the latter case you can select entities by double clicking their ID's.
  The query is always echoed to the report view to locate syntax errors.
 </p>
 <h3>Queries</h3>
 <p>
  You can write a query directly in the option field, or specify a file containing the query.
  An empty query field restores the default example as soon as it gets executed. 
  A '%s' in a query is a place holder for the id of the entity from which the report was launched.
 </p>
 <h2>To do</h2>
 <ul>
  <li>
   Put the jar files of
   <a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a> on the classpath.
  </li>
  <li>Make more dates comparable.</li>
  <li>Add geographical coordinates to places.</li>
  <li>Add examples to compute ages by XSL and xQuery.</li>
  <li>Propably ID's returned by a SPAQRQL query could be used as an export filter.</li>
 </ul>
 <h2>Revisions</h2>
 <ul>
  <li>0.3 - 3 May 2011: Replaced default report. New: show large age differences. Was: count names.</li>
  <li>0.2 - 2 May 2011: A slight change in formating the dates and name parts. Enabled rules</li>
  <li>0.1 - 25 April 2011: Initial revision</li>
 </ul>

###########################################################
#################### option labels ########################
###########################################################

uriFormats = format for entity URIs ({0} is a place holder for id's)

fam = family
indi = individual
obje = object
note = note
sour = source
repo = repository
subm = submitter

displayFormats = which results and how to show them (clear file name to skip, # to show in panel)

styleSheet = file name of XSL style sheet to embed in the XML result
converted = file name for converted gedcom (extensions: "ttl", "n3", "nt", "rdf")
asXml = file name for query result as XML
asText = file name for query result as plain text
askForOverwrite = ask before overwriting existing files

queries = SPARQL queries (see explanation, clear to restore default)

qFam = family is selected entity
qIndi = individual is selected entity
qGedcom = no entity selected
qRules = rules or shorthands

###########################################################
#################### messages #############################
###########################################################

progress.writing = ######## writing {0}
overwrite.question = {0} allready exists. Overwrite it?
extension.error = "{0}" is not a valid extension for the converted gedcom.
 Use for example "#.n3" to show the output in the report view.
 
#################################################
######### below no further translations   #######
#################################################

query.function.prefixes = \n
 PREFIX  fn: <http://www.w3.org/2005/xpath-functions#> \n
 PREFIX afn: <http://jena.hpl.hp.com/ARQ/function#> \n
 PREFIX apf: <http://jena.hpl.hp.com/ARQ/property#> \n
 \n

query.rules = 
 [(?fam p:WIFE ?wife)   (?fam p:HUSB ?husband)->(?wife r:spouse ?husband)(?husband r:spouse ?wife)]
 [(?fam p:HUSB ?dad )   (?fam p:CHIL ?child  )->(?dad  r:child ?child)(?child r:parent ?dad)]
 [(?fam p:WIFE ?mom )   (?fam p:CHIL ?child  )->(?mom  r:child ?child)(?child r:parent ?mom)]
 [(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)->(?c1 r:sibling ?c2)]
# [(?parent p:FAMS ?fam )(?fam p:CHIL ?child)(?child p:SEX ?s)(?s p:value "M")->(?parent r:son      ?child)]
# [(?parent p:FAMS ?fam )(?fam p:CHIL ?child)(?child p:SEX ?s)(?s p:value "F")->(?parent r:daughter ?child)]
# [(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)(?child p:SEX ?s)(?s p:value "F")->(?c1 r:sister ?c2)]
# [(?fam p:CHIL ?c1)(?fam p:CHIL ?c2)notEqual(?c1,?c2)(?child p:SEX ?s)(?s p:value "M")->(?c1 r:brother ?c2)]
# [(?indi r:spouse ?spouse)(?spouse r:dad ?fil)->(?indi r:fatherInLaw ?fil)]
# [(?indi r:spouse ?spouse)(?spouse r:mom ?fil)->(?indi r:motherInLaw ?mil)]
# [(?child r:parent ?parent)->(?child r:ancestor ?parent)]
# [(?a r:ancestor ?b)(?b r:ancestor ?c)->(?a r:ancestor ?c)]
# [(?parent r:child ?child)->(?parent r:descendant ?child)]
# [(?a r:descendant ?b)(?b r:descendant ?c)->(?a r:descendant ?c)]


# large age differences between husband and wife
query.gedcom = 
 SELECT 
  (str(?idHusb) as ?idM) 
  (?yearHusb as ?birthM) 
  (str(?idWife)as ?idF) 
  (?yearWife as ?birthF) 
  ?diff
 {
  ?fam p:HUSB ?husb; p:WIFE ?wife.
  ?husb p:id ?idHusb; p:BIRT [p:DATE [p:value ?dateHusb]].
  ?wife p:id ?idWife;  p:BIRT [p:DATE [p:value ?dateWife]].
  LET (?yearHusb := fn:substring(str(?dateHusb),0,4))
  LET (?yearWife := fn:substring(str(?dateWife),0,4))
  LET (?diff := xsd:int(?yearHusb) - xsd:int(?yearWife))
  FILTER (?diff > 20 || ?diff < -20)
 } 
 ORDER BY ?diff

# shows the configuration of a patchwork family (remarried widow and widower)
query.fam =
 SELECT DISTINCT 
  ?name1 
  ?name2 
  (?nameChild as ?child)
 {
  ?fam1 
   p:id '%s';
   p:HUSB ?husb1.
  ?indi1
   p:FAMS ?fam1, ?fam2;
   p:NAME [p:value ?name1].
  ?indi2
   p:FAMS ?fam2;
   p:NAME [p:value ?name2].
  ?fam2 p:CHIL ?child2.
  ?child2 p:NAME [p:first ?nameChild].
  FILTER( ?indi1 != ?indi2 && ?indi2 != ?husb1)
 }

# time line with births, deaths and marriages of close relatives
query.indi = 
 SELECT DISTINCT 
  (fn:substring(str(?eventDate),0,10) as ?date)
  ((?birthDate <= ?eventDate && ?eventDate <= ?deathDate) as ?selectedPersonAlive)
  ?eventType
  ?name
 {
  ?indi 
   p:id '%s';
   p:BIRT [p:DATE [p:value ?birthDate]];
   p:DEAT [p:DATE [p:value ?deathDate]].
  {?indi                              p:NAME [p:value ?name]; p:BIRT [p:DATE [p:value ?eventDate]]. LET (?eventType := "born").}UNION
  {?indi                              p:NAME [p:value ?name]; p:DEAT [p:DATE [p:value ?eventDate]]. LET (?eventType := "died").}UNION
  {?indi r:parent  ?parent.   ?parent p:NAME [p:value ?name]; p:BIRT [p:DATE [p:value ?eventDate]]. LET (?eventType := "parent born").}UNION
  {?indi r:parent  ?parent.   ?parent p:NAME [p:value ?name]; p:DEAT [p:DATE [p:value ?eventDate]]. LET (?eventType := "parent died").}UNION
  {?indi r:child   ?child.     ?child p:NAME [p:value ?name]; p:BIRT [p:DATE [p:value ?eventDate]]. LET (?eventType := "child born").}UNION
  {?indi r:child   ?child.     ?child p:NAME [p:value ?name]; p:DEAT [p:DATE [p:value ?eventDate]]. LET (?eventType := "child died").}UNION
  {?indi r:sibling ?sibling. ?sibling p:NAME [p:value ?name]; p:BIRT [p:DATE [p:value ?eventDate]]. LET (?eventType := "sibling born").}UNION
  {?indi r:sibling ?sibling. ?sibling p:NAME [p:value ?name]; p:DEAT [p:DATE [p:value ?eventDate]]. LET (?eventType := "sibling died").}UNION
  {?indi r:spouse  ?spouse.   ?spouse p:NAME [p:value ?name]; p:BIRT [p:DATE [p:value ?eventDate]]. LET (?eventType := "spouse born").}UNION
  {?indi r:spouse  ?spouse.   ?spouse p:NAME [p:value ?name]; p:DEAT [p:DATE [p:value ?eventDate]]. LET (?eventType := "spouse died").}UNION
  {?indi r:spouse  ?spouse.   ?spouse p:NAME [p:value ?name]. 
                 ?indi p:FAMS ?fam. ?spouse p:FAMS ?fam. ?fam p:MARR [p:DATE [p:value ?eventDate]]. LET (?eventType := "married").}UNION
  {?indi r:child  ?child. ?child p:FAMS ?fam; p:NAME [p:value ?name]. 
                                                         ?fam p:MARR [p:DATE [p:value ?eventDate]]. LET (?eventType := "child married").}UNION
  {?indi r:sibling  ?sibling. ?sibling p:FAMS ?fam; p:NAME [p:value ?name]. 
                                                         ?fam p:MARR [p:DATE [p:value ?eventDate]]. LET (?eventType := "sibling married").}
 }
 ORDER BY ?eventDate
 