author   = Jo Pol
version  = 0.1

name     = blueprint based reports and exports
info     =  <h1><center>Blueprint based reports and exports</center></h1>
 <p><b>
  Needs the jar files in 
  <a href="http://sourceforge.net/projects/jena/files/Jena/Jena-2.6.4/">jena-2.6.4.zip</a>
 </b></p>
 <p>
  A <a href="http://openjena.org/ARQ/documentation.html">SPARQL</a> 
  query and a XSL file or XQuery forms a blueprint of a report. 
  The queries can calculate with plain complete Gregorian dates.
 </p>
 <p>
  Note that the N3 (extension n3) and TURTLE (extension ttl) format have a lot in common with SPARQL. 
  So examining the converted gedcom could inspire to write queries.
  These formats should also be easy to compare with the Gedcom mode of GENJ's edit view.
 </p>
 <p>
  Output in the report view allows to select entities by double clicking their ID's.
 </p>
 <p>
  Thw SPARQL query saved as XML, can be transformed into HTML pages with an 
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xsl">xsl style sheet</a> or 
  <a href="http://www.w3.org/TR/rdf-sparql-XMLres/result-to-html.xq">xQuery</a>.
  The options allow to put your copy of the style sheet in the generated XML file.
  Both files should be published in the domain.
  For xQuery you need to put the name of the generated XML file in the xQuery file.
 </p>
 <p><b>To do</b></p>
 <ul>
  <li>Implement rules for ancestors and descendants for powerful queries.</li>
  <li>Propably ID's returned by a SPAQRQL query could be used as an export filter</li>
  <li>See TODO's in the code</li>
 </ul>


uriFormats = format to assemble URIs ({0} becomes I99, F99 etc)
fam = family
indi = individual
obje = object
note = note
sour = source
repo = repository
subm = submitter

displayFormats = which results and how to show them ( file name # means report view)

styleSheet = XSL style sheet (gets embedded in the XML result)
converted = file name for converted gedcom (extensions: "ttl", "n3", "nt", "rdf")
asXml = file name for query result as XML
asText = file name for query result as plain text
askForOverwrite = ask before overwriting existing files

queries = SPARQL queries (%s becomes the id of a family or individual)
qFam = family as starting point
qIndi = individual as starting point
qGedcom = about the whole repository

progress.writing = ######## writing {0}
overwrite.question = {0} allready exists. Overwrite it?
extension.error = "{0}" is not a valid extension for the converted gedcom.
 Use for example "#.n3" to show the output in the report view.

#################################################
######### below no further translations #########
#################################################

queryFunctions = \n
 PREFIX  fn: <http://www.w3.org/2005/xpath-functions#> \n
 PREFIX afn: <http://jena.hpl.hp.com/ARQ/function#> \n
 PREFIX apf: <http://jena.hpl.hp.com/ARQ/property#> \n

# original of the rules: http://www.agfa.com/w3c/euler/gedcom-relations.n3 (by Jos De Roo / AGFA)
# more context at http://lists.w3.org/Archives/Public/www-rdf-logic/2001Mar/0018.html
# needs adjustments to our model as we use a simple 1:1 conversion from gedcom in stead of DAML
queryRules = \n
 @prefix owl: <http://www.w3.org/2002/07/owl#>. \n
 @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>. \n
 @prefix gc: <http://www.daml.org/2001/01/gedcom/gedcom#>. \n
  \n
 gc:parent owl:inverseOf gc:child. \n
 gc:grandparent owl:inverseOf gc:grandchild. \n
 gc:ancestor owl:inverseOf gc:descendent. \n
 gc:sibling a owl:SymmetricProperty. \n
 gc:spouse a owl:SymmetricProperty. \n
 gc:ancestor a owl:TransitiveProperty. \n
 gc:parent rdfs:subPropertyOf gc:ancestor. \n
  \n
 {?C gc:childIn ?F. ?P gc:spouseIn ?F} => {?C gc:parent ?P}. \n
 {?C gc:parent ?P. ?P gc:sex gc:Male} => {?C gc:father ?P}. \n
 {?C gc:parent ?P. ?P gc:sex gc:Female} => {?C gc:mother ?P}. \n
 {?C gc:parent ?P. ?C gc:sex gc:Male} => {?P gc:son ?C}. \n
 {?C gc:parent ?P. ?C gc:sex gc:Female} => {?P gc:daughter ?C}. \n
  \n
 {?C gc:parent ?P. ?P gc:parent ?GP} => {?C gc:grandparent ?GP}. \n
 {?C gc:grandparent ?GP. ?GP gc:sex gc:Male} => {?C gc:grandfather ?GP}. \n
 {?C gc:grandparent ?GP. ?GP gc:sex gc:Female} => {?C gc:grandmother ?GP}. \n
 {?C gc:grandparent ?GP. ?C gc:sex gc:Male} => {?GP gc:grandson ?C}. \n
 {?C gc:grandparent ?GP. ?C gc:sex gc:Female} => {?GP gc:granddaughter ?C}. \n
  \n
 {?C gc:childIn ?F. ?C2 gc:childIn ?F. ?C owl:differentFrom ?C2} => {?C gc:sibling ?C2}. \n
 {?C gc:sibling ?S. ?S gc:sex gc:Male} => {?C gc:brother ?S}. \n
 {?C gc:sibling ?S. ?S gc:sex gc:Female} => {?C gc:sister ?S}. \n
  \n
 {?SP gc:spouseIn ?F. ?SP2 gc:spouseIn ?F. ?SP owl:differentFrom ?SP2} => {?SP gc:spouse ?SP2}. \n
 {?SP gc:spouse ?H. ?H gc:sex gc:Male} => {?SP gc:husband ?H}. \n
 {?SP gc:spouse ?W. ?W gc:sex gc:Female} => {?SP gc:wife ?W}. \n
  \n
 {?C gc:parent ?P. ?P gc:brother ?U} => {?C gc:uncle ?U}. \n
 {?C gc:parent ?P. ?P gc:sister ?A. ?A gc:spouse ?U} => {?C gc:uncle ?U}. \n
 {?C gc:parent ?P. ?P gc:sister ?A} => {?C gc:aunt ?A}. \n
 {?C gc:parent ?P. ?P gc:brother ?U. ?U gc:spouse ?A} => {?C gc:aunt ?A}. \n
  \n
 {?P gc:daughter ?C. ?P gc:sibling ?S} => {?S gc:niece ?C}. \n
 {?P gc:son ?C. ?P gc:sibling ?S} => {?S gc:nephew ?C}. \n
 {?C gc:parent ?S. ?C2 gc:parent ?S2. ?S gc:sibling ?S2} => {?C gc:firstcousin ?C2}. \n
 {?S gc:sibling ?S2. ?S gc:descendent ?D. ?S2 gc:descendent ?D2} => {?D gc:cousin ?D2}. \n

